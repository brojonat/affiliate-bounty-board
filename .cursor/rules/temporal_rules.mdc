---
description:
globs:
alwaysApply: false
---
# Temporal Workflows Best Practices

This document outlines the best practices for working with Temporal workflows and activities in the Affiliate Bounty Board codebase.

## Workflow Structure

1. Keep workflow definitions simple and focused
2. Extract complex logic into helper functions
3. Use descriptive naming for workflows and activities
4. Clearly define and document input/output structures

### Helper Functions

Extract complex operations into helper functions outside the main workflow to improve readability:

```golang
// Good: Helper function with focused responsibility
func awaitBountyFund(
    ctx workflow.Context,
    funderWallet string,
    originalTotalBounty *solana.USDCAmount,
    paymentTimeout time.Duration,
) (*VerifyPaymentResult, error) {
    // Implementation...
}

// Main workflow stays clean and readable
func BountyAssessmentWorkflow(ctx workflow.Context, input BountyAssessmentWorkflowInput) error {
    // ...
    result, err := awaitBountyFund(ctx, input.BountyFunderWallet, input.OriginalTotalBounty, input.PaymentTimeout)
    if err != nil {
        return err
    }
    // ...
}
```

## Activity Implementation

1. Activities should be stateless and deterministic
2. Inject dependencies through a structured Activities object
3. Use consistent error handling
4. Implement proper retries with appropriate backoff

```golang
// Good: Well-structured activity with proper dependency injection
func (a *Activities) TransferUSDC(ctx context.Context, walletAddress string, amount float64) error {
    // Implementation...
}

// Good: Proper activity options with retry policy
options := workflow.ActivityOptions{
    StartToCloseTimeout: 30 * time.Second,
    RetryPolicy: &temporal.RetryPolicy{
        InitialInterval:    time.Second,
        BackoffCoefficient: 2.0,
        MaximumInterval:    time.Minute,
        MaximumAttempts:    3,
    },
}
ctx = workflow.WithActivityOptions(ctx, options)
```

## Signal Handling

1. Define signal channels with clear names
2. Use selectors for handling multiple signals
3. Implement idempotent signal processing
4. Check for validity of signal data

```golang
// Good: Clear signal definition
const AssessmentSignalName = "assessment"

// Good: Signal structure with clear fields
type AssessContentSignal struct {
    ContentID    string       `json:"content_id"`
    PayoutWallet string       `json:"payout_wallet"`
    Platform     PlatformType `json:"platform"`
}

// Good: Signal handling with validation
assessmentChan := workflow.GetSignalChannel(ctx, AssessmentSignalName)
selector.AddReceive(assessmentChan, func(c workflow.ReceiveChannel, more bool) {
    var signal AssessContentSignal
    c.Receive(ctx, &signal)

    // Validate signal data before processing
    if signal.ContentID == "" || signal.PayoutWallet == "" {
        workflow.GetLogger(ctx).Error("Invalid signal data")
        return
    }

    // Process signal...
}
```

## Error Handling

1. Return descriptive errors with context
2. Log appropriate details for debugging
3. Consider which errors should trigger retries
4. Handle activity failures appropriately

```golang
// Good: Detailed error with context
if err != nil {
    return fmt.Errorf("failed to verify payment: %w", err)
}

// Good: Appropriate logging
workflow.GetLogger(ctx).Error("Failed to transfer platform fee",
    "error", err,
    "wallet", treasuryWallet,
    "amount", amount)
```

## Testing

1. Use Temporal's test suite and mock package for workflow testing
2. Mock external dependencies
3. Test timeout and signal handling
4. Verify idempotency

```golang
// Good: Clear test setup
testSuite := &testsuite.WorkflowTestSuite{}
env := testSuite.NewTestWorkflowEnvironment()

// Mock activity behavior
env.OnActivity(activities.TransferUSDC, mock.Anything, "wallet", 10.0).Return(nil)

// Execute workflow
env.ExecuteWorkflow(MyWorkflow, input)

// Verify results
assert.True(t, env.IsWorkflowCompleted())
assert.NoError(t, env.GetWorkflowError())
```

## Platform Integration

When integrating new platforms:

1. Define a consistent dependency structure
2. Implement required interfaces
3. Update the appropriate workflow logic
4. Handle platform-specific error cases

```golang
// Good: Consistent platform dependency structure
type NewPlatformDependencies struct {
    APIKey    string
    APISecret string
    // Other fields...
}

// Good: Platform-specific activity
func (a *Activities) PullNewPlatformContent(ctx context.Context, contentID string) (*NewPlatformContent, error) {
    // Implementation...
}
```
