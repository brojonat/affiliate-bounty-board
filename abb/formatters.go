package abb

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"
)

// FormatRedditContent formats the Reddit content as a JSON string
func FormatRedditContent(content *RedditContent) string {
	// Create a map to hold the formatted content
	formatted := map[string]interface{}{
		"author":     content.Author,
		"subreddit":  content.Subreddit,
		"score":      content.Score,
		"created":    content.Created.Format(time.RFC3339),
		"permalink":  "https://reddit.com" + content.Permalink,
		"is_comment": content.IsComment,
	}

	// Add content-specific fields
	if content.IsComment {
		formatted["body"] = content.Body
	} else {
		formatted["title"] = content.Title
		if content.Selftext != "" {
			formatted["selftext"] = content.Selftext
		}
		if content.URL != "" && !strings.HasPrefix(content.URL, "https://www.reddit.com") {
			formatted["url"] = content.URL
		}
		formatted["num_comments"] = content.NumComments
	}

	// Add metadata flags
	metadata := map[string]bool{
		"is_stickied": content.IsStickied,
		"is_locked":   content.IsLocked,
		"is_nsfw":     content.IsNSFW,
		"is_spoiler":  content.IsSpoiler,
	}
	formatted["metadata"] = metadata

	// Add flair if present
	if content.Flair != "" {
		formatted["flair"] = content.Flair
	}

	// Convert to JSON with indentation
	jsonBytes, err := json.MarshalIndent(formatted, "", "  ")
	if err != nil {
		return fmt.Sprintf("Error formatting content: %v", err)
	}

	return string(jsonBytes)
}

// FormatYouTubeContent formats the YouTube content as a JSON string
func FormatYouTubeContent(content *YouTubeContent) string {
	if content == nil {
		return "No YouTube content available"
	}

	// Create a map to hold the formatted content
	formatted := map[string]interface{}{
		"id":                     content.ID,
		"title":                  content.Title,
		"description":            content.Description,
		"channel_id":             content.ChannelID,
		"channel_title":          content.ChannelTitle,
		"published_at":           content.PublishedAt.Format(time.RFC3339),
		"view_count":             content.ViewCount,
		"like_count":             content.LikeCount,
		"comment_count":          content.CommentCount,
		"duration":               content.Duration,
		"thumbnail_url":          content.ThumbnailURL,
		"tags":                   content.Tags,
		"category_id":            content.CategoryID,
		"live_broadcast_content": content.LiveBroadcastContent,
	}

	// Add captions if available
	if len(content.Captions) > 0 {
		captions := make([]map[string]interface{}, len(content.Captions))
		for i, caption := range content.Captions {
			captions[i] = map[string]interface{}{
				"id":                caption.ID,
				"language":          caption.Language,
				"name":              caption.Name,
				"track_kind":        caption.TrackKind,
				"last_updated":      caption.LastUpdated.Format(time.RFC3339),
				"is_auto_generated": caption.IsAutoGenerated,
			}
			// Only include content if it's not auto-generated
			if !caption.IsAutoGenerated {
				captions[i]["content"] = caption.Content
			}
		}
		formatted["captions"] = captions
	}

	// Convert to JSON with indentation
	jsonBytes, err := json.MarshalIndent(formatted, "", " ")
	if err != nil {
		return fmt.Sprintf("Error formatting content: %v", err)
	}

	return string(jsonBytes)
}
