// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: transaction_history.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestSolanaTransactionForRecipient = `-- name: GetLatestSolanaTransactionForRecipient :one
SELECT signature, slot, block_time, bounty_id, funder_wallet, recipient_wallet, amount_smallest_unit, memo, created_at FROM solana_transactions
WHERE recipient_wallet = $1
ORDER BY block_time DESC
LIMIT 1
`

func (q *Queries) GetLatestSolanaTransactionForRecipient(ctx context.Context, recipientWallet string) (SolanaTransaction, error) {
	row := q.db.QueryRow(ctx, getLatestSolanaTransactionForRecipient, recipientWallet)
	var i SolanaTransaction
	err := row.Scan(
		&i.Signature,
		&i.Slot,
		&i.BlockTime,
		&i.BountyID,
		&i.FunderWallet,
		&i.RecipientWallet,
		&i.AmountSmallestUnit,
		&i.Memo,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestSolanaTransactionForWallet = `-- name: GetLatestSolanaTransactionForWallet :one
SELECT signature, slot, block_time, bounty_id, funder_wallet, recipient_wallet, amount_smallest_unit, memo, created_at FROM solana_transactions
WHERE funder_wallet = $1 OR recipient_wallet = $1
ORDER BY block_time DESC
LIMIT 1
`

func (q *Queries) GetLatestSolanaTransactionForWallet(ctx context.Context, funderWallet string) (SolanaTransaction, error) {
	row := q.db.QueryRow(ctx, getLatestSolanaTransactionForWallet, funderWallet)
	var i SolanaTransaction
	err := row.Scan(
		&i.Signature,
		&i.Slot,
		&i.BlockTime,
		&i.BountyID,
		&i.FunderWallet,
		&i.RecipientWallet,
		&i.AmountSmallestUnit,
		&i.Memo,
		&i.CreatedAt,
	)
	return i, err
}

const getOutgoingSolanaTransactions = `-- name: GetOutgoingSolanaTransactions :many
SELECT signature, slot, block_time, bounty_id, funder_wallet, recipient_wallet, amount_smallest_unit, memo, created_at FROM solana_transactions
WHERE funder_wallet = $1
ORDER BY block_time DESC
LIMIT $2
`

type GetOutgoingSolanaTransactionsParams struct {
	FunderWallet string `json:"funder_wallet"`
	Limit        int32  `json:"limit"`
}

func (q *Queries) GetOutgoingSolanaTransactions(ctx context.Context, arg GetOutgoingSolanaTransactionsParams) ([]SolanaTransaction, error) {
	rows, err := q.db.Query(ctx, getOutgoingSolanaTransactions, arg.FunderWallet, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SolanaTransaction
	for rows.Next() {
		var i SolanaTransaction
		if err := rows.Scan(
			&i.Signature,
			&i.Slot,
			&i.BlockTime,
			&i.BountyID,
			&i.FunderWallet,
			&i.RecipientWallet,
			&i.AmountSmallestUnit,
			&i.Memo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutgoingSolanaTransactionsForBounty = `-- name: GetOutgoingSolanaTransactionsForBounty :many
SELECT signature, slot, block_time, bounty_id, funder_wallet, recipient_wallet, amount_smallest_unit, memo, created_at FROM solana_transactions
WHERE bounty_id = $1
ORDER BY block_time DESC
LIMIT $2
`

type GetOutgoingSolanaTransactionsForBountyParams struct {
	BountyID pgtype.Text `json:"bounty_id"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) GetOutgoingSolanaTransactionsForBounty(ctx context.Context, arg GetOutgoingSolanaTransactionsForBountyParams) ([]SolanaTransaction, error) {
	rows, err := q.db.Query(ctx, getOutgoingSolanaTransactionsForBounty, arg.BountyID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SolanaTransaction
	for rows.Next() {
		var i SolanaTransaction
		if err := rows.Scan(
			&i.Signature,
			&i.Slot,
			&i.BlockTime,
			&i.BountyID,
			&i.FunderWallet,
			&i.RecipientWallet,
			&i.AmountSmallestUnit,
			&i.Memo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSolanaTransactionsByBountyID = `-- name: GetSolanaTransactionsByBountyID :many
SELECT signature, slot, block_time, bounty_id, funder_wallet, recipient_wallet, amount_smallest_unit, memo, created_at FROM solana_transactions
WHERE bounty_id = $1
`

func (q *Queries) GetSolanaTransactionsByBountyID(ctx context.Context, bountyID pgtype.Text) ([]SolanaTransaction, error) {
	rows, err := q.db.Query(ctx, getSolanaTransactionsByBountyID, bountyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SolanaTransaction
	for rows.Next() {
		var i SolanaTransaction
		if err := rows.Scan(
			&i.Signature,
			&i.Slot,
			&i.BlockTime,
			&i.BountyID,
			&i.FunderWallet,
			&i.RecipientWallet,
			&i.AmountSmallestUnit,
			&i.Memo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSolanaTransaction = `-- name: InsertSolanaTransaction :one
INSERT INTO solana_transactions (
    signature,
    slot,
    block_time,
    bounty_id,
    funder_wallet,
    recipient_wallet,
    amount_smallest_unit,
    memo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (signature) DO NOTHING
RETURNING signature, slot, block_time, bounty_id, funder_wallet, recipient_wallet, amount_smallest_unit, memo, created_at
`

type InsertSolanaTransactionParams struct {
	Signature          string             `json:"signature"`
	Slot               int64              `json:"slot"`
	BlockTime          pgtype.Timestamptz `json:"block_time"`
	BountyID           pgtype.Text        `json:"bounty_id"`
	FunderWallet       string             `json:"funder_wallet"`
	RecipientWallet    string             `json:"recipient_wallet"`
	AmountSmallestUnit int64              `json:"amount_smallest_unit"`
	Memo               pgtype.Text        `json:"memo"`
}

func (q *Queries) InsertSolanaTransaction(ctx context.Context, arg InsertSolanaTransactionParams) (SolanaTransaction, error) {
	row := q.db.QueryRow(ctx, insertSolanaTransaction,
		arg.Signature,
		arg.Slot,
		arg.BlockTime,
		arg.BountyID,
		arg.FunderWallet,
		arg.RecipientWallet,
		arg.AmountSmallestUnit,
		arg.Memo,
	)
	var i SolanaTransaction
	err := row.Scan(
		&i.Signature,
		&i.Slot,
		&i.BlockTime,
		&i.BountyID,
		&i.FunderWallet,
		&i.RecipientWallet,
		&i.AmountSmallestUnit,
		&i.Memo,
		&i.CreatedAt,
	)
	return i, err
}
