// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: bounty_summary.sql

package dbgen

import (
	"context"
)

const getBountySummary = `-- name: GetBountySummary :one
SELECT summary
FROM bounty_summaries
WHERE bounty_id = $1
`

func (q *Queries) GetBountySummary(ctx context.Context, bountyID string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getBountySummary, bountyID)
	var summary []byte
	err := row.Scan(&summary)
	return summary, err
}

const updateBountySummary = `-- name: UpdateBountySummary :exec
UPDATE bounty_summaries
SET summary = $1
WHERE bounty_id = $2
`

type UpdateBountySummaryParams struct {
	Summary  []byte `json:"summary"`
	BountyID string `json:"bounty_id"`
}

func (q *Queries) UpdateBountySummary(ctx context.Context, arg UpdateBountySummaryParams) error {
	_, err := q.db.Exec(ctx, updateBountySummary, arg.Summary, arg.BountyID)
	return err
}

const upsertBountySummary = `-- name: UpsertBountySummary :exec
INSERT INTO bounty_summaries (bounty_id, summary)
VALUES ($1, $2)
ON CONFLICT (bounty_id) DO UPDATE
SET summary = EXCLUDED.summary
`

type UpsertBountySummaryParams struct {
	BountyID string `json:"bounty_id"`
	Summary  []byte `json:"summary"`
}

func (q *Queries) UpsertBountySummary(ctx context.Context, arg UpsertBountySummaryParams) error {
	_, err := q.db.Exec(ctx, upsertBountySummary, arg.BountyID, arg.Summary)
	return err
}
