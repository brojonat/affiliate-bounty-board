// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: gumroad.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getExistingGumroadSaleIDs = `-- name: GetExistingGumroadSaleIDs :many
SELECT id FROM gumroad_sales WHERE id = ANY($1::text[])
`

func (q *Queries) GetExistingGumroadSaleIDs(ctx context.Context, saleIds []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getExistingGumroadSaleIDs, saleIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnnotifiedGumroadSales = `-- name: GetUnnotifiedGumroadSales :many
SELECT id, product_id, product_name, permalink, product_permalink, email, price, gumroad_fee, currency, quantity, discover_fee_charged, can_contact, referrer, order_number, sale_id, sale_timestamp, purchaser_id, subscription_id, license_key, is_multiseat_license, ip_country, recurrence, is_gift_receiver_purchase, refunded, disputed, dispute_won, created_at, chargebacked, subscription_ended_at, subscription_cancelled_at, subscription_failed_at, it_notified, it_api_key
FROM gumroad_sales
WHERE it_notified IS DISTINCT FROM TRUE
`

func (q *Queries) GetUnnotifiedGumroadSales(ctx context.Context) ([]GumroadSale, error) {
	rows, err := q.db.Query(ctx, getUnnotifiedGumroadSales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GumroadSale
	for rows.Next() {
		var i GumroadSale
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.Permalink,
			&i.ProductPermalink,
			&i.Email,
			&i.Price,
			&i.GumroadFee,
			&i.Currency,
			&i.Quantity,
			&i.DiscoverFeeCharged,
			&i.CanContact,
			&i.Referrer,
			&i.OrderNumber,
			&i.SaleID,
			&i.SaleTimestamp,
			&i.PurchaserID,
			&i.SubscriptionID,
			&i.LicenseKey,
			&i.IsMultiseatLicense,
			&i.IpCountry,
			&i.Recurrence,
			&i.IsGiftReceiverPurchase,
			&i.Refunded,
			&i.Disputed,
			&i.DisputeWon,
			&i.CreatedAt,
			&i.Chargebacked,
			&i.SubscriptionEndedAt,
			&i.SubscriptionCancelledAt,
			&i.SubscriptionFailedAt,
			&i.ItNotified,
			&i.ItApiKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGumroadSale = `-- name: InsertGumroadSale :exec
INSERT INTO gumroad_sales (
    id,
    product_id,
    product_name,
    permalink,
    product_permalink,
    email,
    price,
    gumroad_fee,
    currency,
    quantity,
    discover_fee_charged,
    can_contact,
    referrer,
    order_number,
    sale_id,
    sale_timestamp,
    purchaser_id,
    subscription_id,
    license_key,
    is_multiseat_license,
    ip_country,
    recurrence,
    is_gift_receiver_purchase,
    refunded,
    disputed,
    dispute_won,
    created_at,
    chargebacked,
    subscription_ended_at,
    subscription_cancelled_at,
    subscription_failed_at,
    it_notified,
    it_api_key
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,
    $31, $32, $33
)
ON CONFLICT (id) DO NOTHING
`

type InsertGumroadSaleParams struct {
	ID                      string             `json:"id"`
	ProductID               string             `json:"product_id"`
	ProductName             pgtype.Text        `json:"product_name"`
	Permalink               pgtype.Text        `json:"permalink"`
	ProductPermalink        pgtype.Text        `json:"product_permalink"`
	Email                   string             `json:"email"`
	Price                   pgtype.Int8        `json:"price"`
	GumroadFee              pgtype.Int8        `json:"gumroad_fee"`
	Currency                pgtype.Text        `json:"currency"`
	Quantity                pgtype.Int4        `json:"quantity"`
	DiscoverFeeCharged      pgtype.Bool        `json:"discover_fee_charged"`
	CanContact              pgtype.Bool        `json:"can_contact"`
	Referrer                pgtype.Text        `json:"referrer"`
	OrderNumber             pgtype.Int8        `json:"order_number"`
	SaleID                  pgtype.Text        `json:"sale_id"`
	SaleTimestamp           pgtype.Timestamptz `json:"sale_timestamp"`
	PurchaserID             pgtype.Text        `json:"purchaser_id"`
	SubscriptionID          pgtype.Text        `json:"subscription_id"`
	LicenseKey              pgtype.Text        `json:"license_key"`
	IsMultiseatLicense      pgtype.Bool        `json:"is_multiseat_license"`
	IpCountry               pgtype.Text        `json:"ip_country"`
	Recurrence              pgtype.Text        `json:"recurrence"`
	IsGiftReceiverPurchase  pgtype.Bool        `json:"is_gift_receiver_purchase"`
	Refunded                pgtype.Bool        `json:"refunded"`
	Disputed                pgtype.Bool        `json:"disputed"`
	DisputeWon              pgtype.Bool        `json:"dispute_won"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	Chargebacked            pgtype.Bool        `json:"chargebacked"`
	SubscriptionEndedAt     pgtype.Timestamptz `json:"subscription_ended_at"`
	SubscriptionCancelledAt pgtype.Timestamptz `json:"subscription_cancelled_at"`
	SubscriptionFailedAt    pgtype.Timestamptz `json:"subscription_failed_at"`
	ItNotified              pgtype.Bool        `json:"it_notified"`
	ItApiKey                pgtype.Text        `json:"it_api_key"`
}

func (q *Queries) InsertGumroadSale(ctx context.Context, arg InsertGumroadSaleParams) error {
	_, err := q.db.Exec(ctx, insertGumroadSale,
		arg.ID,
		arg.ProductID,
		arg.ProductName,
		arg.Permalink,
		arg.ProductPermalink,
		arg.Email,
		arg.Price,
		arg.GumroadFee,
		arg.Currency,
		arg.Quantity,
		arg.DiscoverFeeCharged,
		arg.CanContact,
		arg.Referrer,
		arg.OrderNumber,
		arg.SaleID,
		arg.SaleTimestamp,
		arg.PurchaserID,
		arg.SubscriptionID,
		arg.LicenseKey,
		arg.IsMultiseatLicense,
		arg.IpCountry,
		arg.Recurrence,
		arg.IsGiftReceiverPurchase,
		arg.Refunded,
		arg.Disputed,
		arg.DisputeWon,
		arg.CreatedAt,
		arg.Chargebacked,
		arg.SubscriptionEndedAt,
		arg.SubscriptionCancelledAt,
		arg.SubscriptionFailedAt,
		arg.ItNotified,
		arg.ItApiKey,
	)
	return err
}

const updateGumroadSaleNotification = `-- name: UpdateGumroadSaleNotification :exec
UPDATE gumroad_sales
SET it_notified = TRUE, it_api_key = $1
WHERE id = $2
`

type UpdateGumroadSaleNotificationParams struct {
	ApiKey pgtype.Text `json:"api_key"`
	ID     string      `json:"id"`
}

func (q *Queries) UpdateGumroadSaleNotification(ctx context.Context, arg UpdateGumroadSaleNotificationParams) error {
	_, err := q.db.Exec(ctx, updateGumroadSaleNotification, arg.ApiKey, arg.ID)
	return err
}
